#!/usr/bin/env node

import express from "express";
import cors from "cors";
import dotenv from "dotenv";
import path from "path";
import { fileURLToPath } from 'url';
import fs from "fs";
import axios from "axios";
import https from "https";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const projectRoot = path.resolve(__dirname, '..');

dotenv.config({ path: path.join(projectRoot, '.env') });

const app = express();
const PORT = process.env.PORT || 8080;

// CORS ÏÑ§Ï†ï
app.use(cors({
  origin: '*',
  methods: ['GET', 'POST', 'OPTIONS'],
  allowedHeaders: ['*'],
  credentials: false
}));

app.use(express.json());

// ÏöîÏ≤≠ Î°úÍπÖ ÎØ∏Îì§Ïõ®Ïñ¥
app.use((req, res, next) => {
  const timestamp = new Date().toISOString();
  console.log(`\nüîç [${timestamp}] ${req.method} ${req.url}`);
  console.log(`   üì° IP: ${req.ip}`);
  console.log(`   üìã Headers:`, JSON.stringify(req.headers, null, 2));
  
  if (req.method === 'POST' && req.body) {
    console.log(`   üì¶ Body:`, JSON.stringify(req.body, null, 2));
  }
  
  // ÏùëÎãµ Î°úÍπÖ
  const originalSend = res.send;
  res.send = function(data) {
    console.log(`   ‚úÖ Response: ${res.statusCode}`);
    if (data) {
      console.log(`   üì§ Response Data:`, typeof data === 'string' ? data.substring(0, 200) : data);
    }
    console.log(`   ‚è±Ô∏è  Duration: ${Date.now() - new Date(timestamp).getTime()}ms\n`);
    return originalSend.call(this, data);
  };
  
  next();
});

// Ïò§ÎîîÏò§ ÌååÏùº Ï†ÄÏû• ÎîîÎ†âÌÜ†Î¶¨
const audioDir = path.join(projectRoot, 'generated_audio');
if (!fs.existsSync(audioDir)) {
  fs.mkdirSync(audioDir, { recursive: true });
}

// Ï†ïÏ†Å ÌååÏùº Ï†úÍ≥µ
app.use('/audio', express.static(audioDir));

// MCP ÏÑúÎ≤Ñ Ï†ïÎ≥¥
const SERVER_INFO = {
  name: "openai-tts-server",
  version: "1.0.0",
  protocolVersion: "2024-11-05",  // ClaudeÍ∞Ä ÏßÄÏõêÌïòÎäî ÌîÑÎ°úÌÜ†ÏΩú Î≤ÑÏ†Ñ
  capabilities: {
    tools: {}
  },
  // Ïù∏Ï¶ù ÏóÜÎäî ÏÑúÎ≤ÑÏûÑÏùÑ Î™ÖÏãú
  auth: {
    type: "none"
  }
};

// ÎèÑÍµ¨ Ï†ïÏùò
const TOOLS = [
  {
    name: "text_to_speech",
    description: "ÌÖçÏä§Ìä∏Î•º ÏùåÏÑ±ÏúºÎ°ú Î≥ÄÌôòÌï©ÎãàÎã§. OpenAIÏùò TTS APIÎ•º ÏÇ¨Ïö©Ìï©ÎãàÎã§.",
    inputSchema: {
      type: "object",
      properties: {
        text: {
          type: "string",
          description: "ÏùåÏÑ±ÏúºÎ°ú Î≥ÄÌôòÌï† ÌÖçÏä§Ìä∏",
        },
        voice: {
          type: "string",
          enum: ["alloy", "echo", "fable", "onyx", "nova", "shimmer"],
          default: "alloy",
          description: "ÏÇ¨Ïö©Ìï† ÏùåÏÑ± Ï¢ÖÎ•ò",
        },
        model: {
          type: "string",
          enum: ["tts-1", "tts-1-hd"],
          default: "tts-1",
          description: "ÏÇ¨Ïö©Ìï† TTS Î™®Îç∏",
        },
        speed: {
          type: "number",
          minimum: 0.25,
          maximum: 4.0,
          default: 1.0,
          description: "ÏùåÏÑ± ÏÜçÎèÑ",
        },
        format: {
          type: "string",
          enum: ["mp3", "opus", "aac", "flac"],
          default: "mp3",
          description: "Ïò§ÎîîÏò§ ÌååÏùº ÌòïÏãù",
        },
      },
      required: ["text"],
    },
  },
  {
    name: "list_audio_files",
    description: "ÏÉùÏÑ±Îêú Ïò§ÎîîÏò§ ÌååÏùº Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.",
    inputSchema: {
      type: "object",
      properties: {},
    },
  },
];

// MCP ÏóîÎìúÌè¨Ïù∏Ìä∏ GET ÏöîÏ≤≠ (ÏÑúÎ≤Ñ Î∞úÍ≤¨Ïö©)
app.get('/mcp/v1/messages', (req, res) => {
  res.json({
    name: SERVER_INFO.name,
    version: SERVER_INFO.version,
    protocolVersion: SERVER_INFO.protocolVersion,
    capabilities: SERVER_INFO.capabilities,
    transport: {
      type: "http",
      endpoint: "/mcp/v1/messages"
    },
    auth: SERVER_INFO.auth,
    description: "OpenAI TTS Remote MCP Server - Use POST for actual MCP messages"
  });
});

// Streamable HTTP ÏóîÎìúÌè¨Ïù∏Ìä∏ - MCP Î©îÏãúÏßÄ Ï≤òÎ¶¨
app.post('/mcp/v1/messages', async (req, res) => {
  const message = req.body;
  
  try {
    let response;

    switch (message.method) {
      case 'initialize':
        response = {
          jsonrpc: "2.0",
          id: message.id,
          result: {
            protocolVersion: SERVER_INFO.protocolVersion,
            capabilities: SERVER_INFO.capabilities,
            serverInfo: {
              name: SERVER_INFO.name,
              version: SERVER_INFO.version
            }
          }
        };
        break;

      case 'tools/list':
        response = {
          jsonrpc: "2.0",
          id: message.id,
          result: {
            tools: TOOLS
          }
        };
        break;

      case 'tools/call':
        const { name, arguments: args } = message.params;
        let toolResult;

        if (name === 'text_to_speech') {
          toolResult = await handleTextToSpeech(args);
        } else if (name === 'list_audio_files') {
          toolResult = await handleListAudioFiles();
        } else {
          throw new Error(`Unknown tool: ${name}`);
        }

        response = {
          jsonrpc: "2.0",
          id: message.id,
          result: toolResult
        };
        break;

      default:
        response = {
          jsonrpc: "2.0",
          id: message.id,
          error: {
            code: -32601,
            message: `Unknown method: ${message.method}`
          }
        };
    }

    res.json(response);
  } catch (error) {
    console.error('Error processing message:', error);
    res.status(500).json({
      jsonrpc: "2.0",
      id: message.id,
      error: {
        code: -32603,
        message: error.message
      }
    });
  }
});

// TTS Ï≤òÎ¶¨ Ìï®Ïàò
async function handleTextToSpeech(args) {
  const {
    text,
    voice = "alloy",
    model = "tts-1",
    speed = 1.0,
    format = "mp3",
  } = args;

  if (!text || text.trim() === "") {
    throw new Error("ÌÖçÏä§Ìä∏Í∞Ä Ï†úÍ≥µÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.");
  }

  if (!process.env.OPENAI_API_KEY) {
    throw new Error("OPENAI_API_KEY ÌôòÍ≤ΩÎ≥ÄÏàòÍ∞Ä ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.");
  }

  // ÌååÏùºÎ™Ö ÏÉùÏÑ±
  const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
  const textPreview = text.substring(0, 30).replace(/[^a-zA-Z0-9Í∞Ä-Ìû£]/g, "_");
  const filename = `tts_${timestamp}_${textPreview}.${format}`;
  const filepath = path.join(audioDir, filename);

  // SSL Í≤ÄÏ¶ù ÎπÑÌôúÏÑ±ÌôîÎêú HTTPS ÏóêÏù¥Ï†ÑÌä∏
  const httpsAgent = new https.Agent({
    rejectUnauthorized: false
  });

  // OpenAI TTS API Ìò∏Ï∂ú
  const response = await axios({
    method: 'POST',
    url: 'https://api.openai.com/v1/audio/speech',
    headers: {
      'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
      'Content-Type': 'application/json',
    },
    data: {
      model: model,
      voice: voice,
      input: text,
      speed: speed,
      response_format: format,
    },
    responseType: 'arraybuffer',
    httpsAgent: httpsAgent,
    timeout: 30000,
  });

  // Ïò§ÎîîÏò§ Îç∞Ïù¥ÌÑ∞Î•º ÌååÏùºÎ°ú Ï†ÄÏû•
  const buffer = Buffer.from(response.data);
  fs.writeFileSync(filepath, buffer);

  return {
    content: [
      {
        type: "text",
        text: `‚úÖ ÌÖçÏä§Ìä∏Í∞Ä ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏùåÏÑ±ÏúºÎ°ú Î≥ÄÌôòÎêòÏóàÏäµÎãàÎã§!

üìù **ÏûÖÎ†• ÌÖçÏä§Ìä∏**: ${text}
üéµ **ÏùåÏÑ±**: ${voice}
ü§ñ **Î™®Îç∏**: ${model}
‚ö° **ÏÜçÎèÑ**: ${speed}x
üìÅ **ÌòïÏãù**: ${format}
üíæ **ÌååÏùºÎ™Ö**: ${filename}
üìä **ÌÅ¨Í∏∞**: ${(buffer.length / 1024).toFixed(2)} KB

ÌååÏùºÏù¥ ÏÑúÎ≤ÑÏóê Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§.`,
      },
    ],
  };
}

// ÌååÏùº Î™©Î°ù Ï≤òÎ¶¨ Ìï®Ïàò
async function handleListAudioFiles() {
  if (!fs.existsSync(audioDir)) {
    return {
      content: [
        {
          type: "text",
          text: "ÏÉùÏÑ±Îêú Ïò§ÎîîÏò§ ÌååÏùºÏù¥ ÏóÜÏäµÎãàÎã§.",
        },
      ],
    };
  }

  const files = fs.readdirSync(audioDir);
  const audioFiles = files.filter(file =>
    file.endsWith('.mp3') ||
    file.endsWith('.opus') ||
    file.endsWith('.aac') ||
    file.endsWith('.flac')
  );

  if (audioFiles.length === 0) {
    return {
      content: [
        {
          type: "text",
          text: "ÏÉùÏÑ±Îêú Ïò§ÎîîÏò§ ÌååÏùºÏù¥ ÏóÜÏäµÎãàÎã§.",
        },
      ],
    };
  }

  const fileList = audioFiles.map((file, index) => {
    const filepath = path.join(audioDir, file);
    const stats = fs.statSync(filepath);
    const size = (stats.size / 1024).toFixed(2);
    const created = stats.birthtime.toLocaleString('ko-KR');

    return `${index + 1}. **${file}**\n   üìÅ ÌÅ¨Í∏∞: ${size} KB\n   üìÖ ÏÉùÏÑ±Ïùº: ${created}`;
  }).join('\n\n');

  return {
    content: [
      {
        type: "text",
        text: `üéµ **ÏÉùÏÑ±Îêú Ïò§ÎîîÏò§ ÌååÏùº Î™©Î°ù** (Ï¥ù ${audioFiles.length}Í∞ú)\n\n${fileList}`,
      },
    ],
  };
}

// MCP ÏÑúÎ≤Ñ Î∞úÍ≤¨ ÏóîÎìúÌè¨Ïù∏Ìä∏ (.well-known)
app.get('/.well-known/mcp', (req, res) => {
  res.json({
    name: SERVER_INFO.name,
    version: SERVER_INFO.version,
    protocolVersion: SERVER_INFO.protocolVersion,
    capabilities: SERVER_INFO.capabilities,
    transport: {
      type: "http",
      endpoint: "/mcp/v1/messages"
    },
    auth: SERVER_INFO.auth,
    description: "OpenAI TTS Remote MCP Server"
  });
});

// MCP ÏÑúÎ≤Ñ Ï†ïÎ≥¥ ÏóîÎìúÌè¨Ïù∏Ìä∏ (Claude Desktop Í≤ÄÏ¶ùÏö©)
app.get('/mcp/v1/server-info', (req, res) => {
  res.json({
    name: SERVER_INFO.name,
    version: SERVER_INFO.version,
    protocolVersion: SERVER_INFO.protocolVersion,
    capabilities: SERVER_INFO.capabilities,
    auth: SERVER_INFO.auth,
    description: "OpenAI TTS Remote MCP Server"
  });
});

// ÏÑúÎ≤Ñ Ï†ïÎ≥¥ ÏóîÎìúÌè¨Ïù∏Ìä∏ (Claude Desktop ÏûêÎèô Î∞úÍ≤¨Ïö©)
app.get('/', (req, res) => {
  res.json({
    name: SERVER_INFO.name,
    version: SERVER_INFO.version,
    description: "OpenAI TTS Remote MCP Server",
    protocolVersion: SERVER_INFO.protocolVersion,
    capabilities: SERVER_INFO.capabilities,
    transport: {
      type: "http",
      endpoint: "/mcp/v1/messages"
    },
    endpoints: {
      messages: "/mcp/v1/messages",
      serverInfo: "/mcp/v1/server-info",
      health: "/health"
    }
  });
});

// Ìó¨Ïä§ Ï≤¥ÌÅ¨
app.get('/health', (req, res) => {
  res.json({
    status: 'healthy',
    server: SERVER_INFO.name,
    version: SERVER_INFO.version,
    timestamp: new Date().toISOString()
  });
});

// ÏÑúÎ≤Ñ ÏãúÏûë
app.listen(PORT, '0.0.0.0', () => {
  console.log(`üöÄ Remote MCP TTS ÏÑúÎ≤ÑÍ∞Ä Ìè¨Ìä∏ ${PORT}ÏóêÏÑú ÏãúÏûëÎêòÏóàÏäµÎãàÎã§.`);
  console.log(`üíö Ìó¨Ïä§ Ï≤¥ÌÅ¨: http://0.0.0.0:${PORT}/health`);
  console.log(`üîå MCP ÏóîÎìúÌè¨Ïù∏Ìä∏: http://0.0.0.0:${PORT}/mcp/v1/messages`);
  console.log(`üåê ÏÑúÎ≤Ñ Ï†ïÎ≥¥: http://0.0.0.0:${PORT}/`);
}); 